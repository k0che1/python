'''
На вход подаётся список чисел (строка, где числа разделены запятой).
Создайте и сохраните:
в переменную V1 Numpy вектор из этих чисел в том же порядке
в переменную V2 Numpy вектор, содержащий только предпоследнее число (это должен быть именно вектор!)
в переменную V3 Numpy вектор из этих чисел в обратном порядке
в переменную V4 Numpy вектор из этих чисел, начиная с 0-ого, через 2 (т.е. каждое третье число)
в переменную V5 Numpy вектор, созданный из генератора Range, содержащий столько элементов, сколько было передано чисел на вход
'''
import numpy as np
v=[float(i) for i in input().split(',')]

V1 = np.array((v))
V2 = np.array((v[-2:-1]))
V3 = np.array((list(reversed(v))))
V4 = np.array((v[::3]))
V5 = np.arange((len(v)))



'''
На вход подаётся 2 набора целых чисел (они представляют из себя вектора равной длины, т.е. с одинаковым количеством элементов).
Используя векторные операции создайте и сохраните:
в переменную V1 Numpy вектор с числами из 1 строки
в переменную V2 Numpy вектор с числами из 2 строки
в переменную V3 Numpy вектор с покоординатными суммами V1 и V2
в переменную V4 Numpy вектор с покоординатными произведениями каждого второго числа V1 на каждое второе число V2, развёрнутого в обратном порядке
'''
import numpy as np
v11=[int(i) for i in input().split(',')]
v22=[int(i) for i in input().split(',')]
v33=[]
V1 = np.array(v11)
V2 = np.array(v22)
V3 = V1+V2
v33=[]
v22.reverse()
for i in range(0,len(v11),2):
  v33.append(v11[i]*v22[i])
V4 = np.array(v33)



'''
        Numpy-100
'''
'''
Считайте число n. Создайте в переменной Z Numpy вектор из нулей длины n.
'''
import numpy as np
n=int(input())
Z=np.zeros(n)

'''
Посчитайте размер матрицы Z в байтах и выведите его на печать.
'''
print(Z.itemsize*Z.size)

'''
Считайте 2 числа n, m. Создайте вектор Z состоящий из чисел от n до m с шагом 1.
'''
#1
Z=np.arange(int(input()),int(input())+1)
#2
n, m=int(input()), int(input())
Z=np.arange(n,m+1,1)


'''
Дан вектор Z. "Разверните" его.
'''
Z=Z[::-1]

'''
Считайте 3 числа:
n - количество элементов матрицы
m и k - размеры матрицы (число строк и столбцов соответственно)
Заполните матрицу Z числами от 0 до n-1 по порядку (сперва строки, потом столбцы).
'''
n=int(input())
m,k=int(input()), int(input())
Z=np.arange(0,n)
Z.shape=m,k


'''
Дан вектор Z. Запишите в переменную NonZerros индексы ненулевых элементов.
'''
NonZerros=np.nonzero(Z)


'''
Дана матрица чисел Z (Z может быть 1, 2 или даже 3 мерной). Выведите на печать список чисел из этой матрицы, которые больше 3.
'''
a=Z.flatten()
q=[a[i] for i in range (np.size(a)) if a[i]>3]
print(q)


'''
Считайте число n. Создайте единичную матрицу размера n, сохраните результат в переменную Z.
'''
a =int(input())
Z=np.eye(a)


'''
Считайте 3 числа: n, m, l.
Зафиксируйте значение генератора случайных чисел Numpy с помощью 'numpy.random.seed(42)'         
Создайте матрицу n*m*l из случайных чисел (от 0 до 1) и сохраните результат в переменную Z.
'''
b=[int(i) for i in input().split()]
np.random.seed(42)
Z =np.random.random((b))


'''
Считайте 2 числа: n, m.
Зафиксируйте значение генератора случайных чисел Numpy с помощью 'numpy.random.seed(42)'
Создайте матрицу n*m из случайных чисел (от 0 до 1). Выведите на печать значение минимального и максимального чисел в получившейся матрице (каждое с новой строки).
'''
b=[int(i) for i in input().split()]
np.random.seed(42)
Z =np.random.random((b))
a=Z.flatten()
print(a.min())
print(a.max())


'''
Считайте 2 числа: n, m.
Зафиксируйте значение генератора случайных чисел Numpy с помощью 'numpy.random.seed(42)'                  
Создайте матрицу n*m из случайных чисел (от 0 до 1). Выведите на печать значение среднего для всей матрицы.
'''
b=[int(i) for i in input().split()]
np.random.seed(42)
Z =np.random.random((b))
a=Z.flatten()
print(a.mean())


'''
Считайте 2 числа: n, m.
Зафиксируйте значение генератора случайных чисел Numpy с помощью 'numpy.random.seed(42)' 
Создайте матрицу n*m из случайных чисел (от 0 до 1). Найдите среднее значение для каждого из столбцов. 
Выведите на печать значение минимального и максимального среднего по столбцам (каждое с новой строки).
'''
n,m=[int(i) for i in input().split()]
np.random.seed(42)
Z =np.random.random((n,m))
a=[]
for j in range(Z.shape[1]):
  Zc=Z[:,j]
  a.append(Zc.mean())
print(min(a))    
print(max(a))


'''
Считайте 2 числа: n, m. Создайте матрицу размера n*m такую что: 
На границе матрицы будут стоять 1,Внутри матрицы будут стоять 0.
Сохраните матрицу в переменную Z.Гарантируется, что матрица будет не меньше 3х3.
'''
#1
n,m=[int(i) for i in input().split()]
Z =np.ones((n,m))
Z[1:-1,1:-1]=0
#2
n,m=[int(i) for i in input().split()]
Z =np.zeros((n,m))
Z[0,:],Z[:,0],Z[-1:],Z[:,-1]=1,1,1,1


'''
Имеется матрица Z.Добавьте вокруг имеющихся значений матрицы "забор" из 0.
'''
#1
Z=np.pad(Z,(1,1), mode='constant', constant_values=0)
#2
a,b=Z.shape
Z1=np.zeros((a+2,b+2),dtype=int)      
Z1[1:-1,1:-1]=Z
Z=Z1


'''
Считайте число n. Создайте диагональную матрицу размера n*n. На главной диагонали должны быть числа от 1 до n.
Сохраните матрицу в переменную Z.
'''
n=int(input())
a=[int(i) for i in range(1,n+1)]
Z=np.diagflat(a) 


'''
Считайте 2 числа:
x - сдвиг для единственной ненулевой диагонали в матрице.
k - верхняя граница для интервала чисел на диагонали (т.е. если k = 5, то на диагонали будут стоять числа 1, 2, 3, 4 и 5)
Договоримся о значениях x:
x = 0 - это главная диагональ матрицы
x<0 - диагональ сдвигается вниз на |x| ячеек (если x = -1, то первая не нулевая ячейка будет с координатами (1,0))
x>0 - диагональ сдвигается вправо на |x| ячеек (если x = 1, то первая ненулевая ячейка будет с координатами (0,1))
Обратите внимание, что размер матрицы изменяется в зависимости от сдвига, т.к. вам надо уместить все числа от 1 до k!
'''
sm,raz=[int(i) for i in input().split()]
dag=[int(i) for i in range(1,raz+1)]
Z=np.diagflat(dag,sm)


'''
Считайте 2 числа: n, m. Создайте матрицу размера n*m и "раскрасьте" её в шахматную раскраску. 0 - "чёрное" 1 - "белое"
Ячейка с координатами (0, 0) всегда "чёрная" (т.е. элемент (0, 0) равен 0).
'''
#1
a,b=[int(i) for i in input().split()]
Z=np.tile([[0.,1.],[1.,0.]],(a//2+1,b//2+1))
Z=Z[:a,:b]
#2
a,b=[int(i) for i in input().split()]
Z=np.ones((a,b))
Z[::2,::2]=0
Z[1::2,1::2]=0
#3
a,b=[int(i) for i in input().split()]
Z=np.ones((a,b))
for i in range(a):
  if i%2==0:
    Z[i][::2]=0
  elif i%2==1:
    Z[i][1::2]=0


'''
Если у нас есть матрица (или numpy массив большей размерности), то её можно представить в линейном виде.
Идея в том, что можно каждому элементу матрицы поставить в соответствие индекс.
Даны: индекс i, numpy массив Z.Определите "координаты" элемента с индексом i в Z и выведите кортеж с координатами на печать.
'''
sh=Z.shape
print(np.unravel_index(i,sh))
